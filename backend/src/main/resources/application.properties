spring.application.name=RateWise
spring.config.import=optional:config.properties

# ===============================
# Database (Azure PostgreSQL)
# ===============================
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# Force SSL (most Azure URLs already include sslmode=require; keep both ok)
spring.datasource.hikari.data-source-properties.sslmode=require

# Identify app in pg_stat_activity (super helpful for triage)
spring.datasource.hikari.data-source-properties.applicationName=Ratewise-API

# ===============================
# JPA / Hibernate
# ===============================
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# IMPORTANT: avoid holding DB connections open across web views
spring.jpa.open-in-view=false

# ===============================
# HikariCP (right-size + leak defense)
# ===============================
# Keep it small. If you run multiple instances, total = instances * max-pool-size
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=2

# How long to wait for a connection from the pool
spring.datasource.hikari.connection-timeout=10000

# Lifetime/idle tuned for cloud load balancers and Azure PG
# (Set max-lifetime a bit under any server/LB idle reset; 30m is common)
spring.datasource.hikari.max-lifetime=1800000     
spring.datasource.hikari.idle-timeout=300000       
spring.datasource.hikari.keepalive-time=240000    

# DEV ONLY: surface leaks with stack traces if a borrowed connection
# isn't returned within this time. Remove/raise in prod.
spring.datasource.hikari.leak-detection-threshold=20000
